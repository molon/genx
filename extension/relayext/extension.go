package relayext

import (
	"context"
	"path/filepath"

	"github.com/molon/genx"
	"github.com/molon/genx/pkg/gqlx"
	"github.com/pkg/errors"
	"github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/parser"
)

const (
	header = "Code generated by github.com/molon/genx/extension/relayext. DO NOT EDIT.\n\n"
)

var _ genx.Extension = (*Extension)(nil)

type Extension struct {
	genx.DefaultExtension
	isNodeType      func(nodeName string) bool
	generatedFiles  []*genx.File
	gqlResolverImpl *gqlResolverImplementer
}

func New() *Extension {
	return &Extension{}
}

func (e *Extension) Name() string {
	return "relayext"
}

func (e *Extension) BeforeGenerate(ctx context.Context, r *genx.Runtime) error {
	prototypePattern := filepath.Join(r.OutputDir, r.PrototypeRelPattern)
	sources, err := gqlx.LoadSources(prototypePattern)
	if err != nil {
		return err
	}

	sd, err := parser.ParseSchemas(sources...)
	if err != nil {
		return errors.Wrapf(err, "failed to parse prototype file %s", prototypePattern)
	}

	result, err := enhanceSchema(ctx, sd)
	if err != nil {
		return err
	}
	sd = result.Document
	e.isNodeType = func(nodeName string) bool {
		_, ok := result.Nodes[nodeName]
		return ok
	}

	schemaFile := "schema/schema.genx.graphql"
	schemaBody := gqlx.FormatDocument(sd)
	schemaBody = "# " + header + schemaBody
	schema, err := gqlparser.LoadSchema(&ast.Source{Name: filepath.Base(schemaFile), Input: schemaBody})
	if err != nil {
		return errors.Wrap(err, "failed to validate schema")
	}
	r.Schema = schema

	e.generatedFiles = append(e.generatedFiles, &genx.File{
		RelPath: schemaFile,
		Content: schemaBody,
	})

	return nil
}

func (e *Extension) Generate(ctx context.Context, r *genx.Runtime) (*genx.Result, error) {
	// TODO: 这个机制主要是因为在先前 node 指令已经被删除了，但是现在感觉虽然是生成时指令，但还是应该保留下来，因为这个指令是用来标记 node 类型，有它的意义在，记得调整
	data := NewData(r, func(def *ast.Definition) bool {
		return e.isNodeType(def.Name) && def.Kind == ast.Object
	})

	generatedFiles, err := e.generate(ctx, data)
	if err != nil {
		return nil, err
	}

	e.gqlResolverImpl = &gqlResolverImplementer{
		data: data,
	}
	return &genx.Result{
		Files: append(e.generatedFiles, generatedFiles...),
	}, nil
}

func (e *Extension) generate(ctx context.Context, data *Data) ([]*genx.File, error) {
	var generatedFiles []*genx.File

	modelFiles, err := e.generateModels(ctx, data)
	if err != nil {
		return nil, err
	}
	generatedFiles = append(generatedFiles, modelFiles...)

	resolverFiles, err := e.generateResolvers(ctx, data)
	if err != nil {
		return nil, err
	}
	generatedFiles = append(generatedFiles, resolverFiles...)

	return generatedFiles, nil
}
