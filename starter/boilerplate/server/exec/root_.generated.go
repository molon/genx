// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package exec

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/molon/genx/starter/boilerplate/server/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Company() CompanyResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Task() TaskResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Company struct {
		CreatedAt        func(childComplexity int) int
		Description      func(childComplexity int) int
		Employees        func(childComplexity int, after *string, first *int, before *string, last *int, filterBy *model.UserFilter, orderBy []*model.UserOrder) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		ViewerPermission func(childComplexity int) int
	}

	CompanyConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CompanyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	CompanyViewerPermission struct {
		CanCreate func(childComplexity int) int
		CanDelete func(childComplexity int) int
		CanUpdate func(childComplexity int) int
	}

	CreateCompanyPayload struct {
		ClientMutationID func(childComplexity int) int
		Company          func(childComplexity int) int
	}

	CreateTaskPayload struct {
		ClientMutationID func(childComplexity int) int
		Task             func(childComplexity int) int
	}

	CreateUserPayload struct {
		ClientMutationID func(childComplexity int) int
		User             func(childComplexity int) int
	}

	DeleteCompanyPayload struct {
		ClientMutationID func(childComplexity int) int
		Company          func(childComplexity int) int
	}

	DeleteTaskPayload struct {
		ClientMutationID func(childComplexity int) int
		Task             func(childComplexity int) int
	}

	DeleteUserPayload struct {
		ClientMutationID func(childComplexity int) int
		User             func(childComplexity int) int
	}

	Mutation struct {
		CreateCompany func(childComplexity int, input model.CreateCompanyInput) int
		CreateTask    func(childComplexity int, input model.CreateTaskInput) int
		CreateUser    func(childComplexity int, input model.CreateUserInput) int
		DeleteCompany func(childComplexity int, input model.DeleteCompanyInput) int
		DeleteTask    func(childComplexity int, input model.DeleteTaskInput) int
		DeleteUser    func(childComplexity int, input model.DeleteUserInput) int
		UpdateCompany func(childComplexity int, input model.UpdateCompanyInput) int
		UpdateTask    func(childComplexity int, input model.UpdateTaskInput) int
		UpdateUser    func(childComplexity int, input model.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Companies func(childComplexity int, after *string, first *int, before *string, last *int, filterBy *model.CompanyFilter, orderBy []*model.CompanyOrder) int
		Tasks     func(childComplexity int, after *string, first *int, before *string, last *int, filterBy *model.TaskFilter, orderBy []*model.TaskOrder) int
		Users     func(childComplexity int, after *string, first *int, before *string, last *int, filterBy *model.UserFilter, orderBy []*model.UserOrder) int
	}

	Task struct {
		Assignee         func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Description      func(childComplexity int) int
		ID               func(childComplexity int) int
		Status           func(childComplexity int) int
		Title            func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		ViewerPermission func(childComplexity int) int
	}

	TaskConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TaskViewerPermission struct {
		CanCreate func(childComplexity int) int
		CanDelete func(childComplexity int) int
		CanUpdate func(childComplexity int) int
	}

	UpdateCompanyPayload struct {
		ClientMutationID func(childComplexity int) int
		Company          func(childComplexity int) int
	}

	UpdateTaskPayload struct {
		ClientMutationID func(childComplexity int) int
		Task             func(childComplexity int) int
	}

	UpdateUserPayload struct {
		ClientMutationID func(childComplexity int) int
		User             func(childComplexity int) int
	}

	User struct {
		Age              func(childComplexity int) int
		Company          func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Description      func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		Tasks            func(childComplexity int, after *string, first *int, before *string, last *int, filterBy *model.TaskFilter, orderBy []*model.TaskOrder) int
		UpdatedAt        func(childComplexity int) int
		ViewerPermission func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		Nodes      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	UserViewerPermission struct {
		CanCreate func(childComplexity int) int
		CanDelete func(childComplexity int) int
		CanUpdate func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Company.createdAt":
		if e.complexity.Company.CreatedAt == nil {
			break
		}

		return e.complexity.Company.CreatedAt(childComplexity), true

	case "Company.description":
		if e.complexity.Company.Description == nil {
			break
		}

		return e.complexity.Company.Description(childComplexity), true

	case "Company.employees":
		if e.complexity.Company.Employees == nil {
			break
		}

		args, err := ec.field_Company_employees_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Company.Employees(childComplexity, args["after"].(*string), args["first"].(*int), args["before"].(*string), args["last"].(*int), args["filterBy"].(*model.UserFilter), args["orderBy"].([]*model.UserOrder)), true

	case "Company.id":
		if e.complexity.Company.ID == nil {
			break
		}

		return e.complexity.Company.ID(childComplexity), true

	case "Company.name":
		if e.complexity.Company.Name == nil {
			break
		}

		return e.complexity.Company.Name(childComplexity), true

	case "Company.updatedAt":
		if e.complexity.Company.UpdatedAt == nil {
			break
		}

		return e.complexity.Company.UpdatedAt(childComplexity), true

	case "Company.viewerPermission":
		if e.complexity.Company.ViewerPermission == nil {
			break
		}

		return e.complexity.Company.ViewerPermission(childComplexity), true

	case "CompanyConnection.edges":
		if e.complexity.CompanyConnection.Edges == nil {
			break
		}

		return e.complexity.CompanyConnection.Edges(childComplexity), true

	case "CompanyConnection.nodes":
		if e.complexity.CompanyConnection.Nodes == nil {
			break
		}

		return e.complexity.CompanyConnection.Nodes(childComplexity), true

	case "CompanyConnection.pageInfo":
		if e.complexity.CompanyConnection.PageInfo == nil {
			break
		}

		return e.complexity.CompanyConnection.PageInfo(childComplexity), true

	case "CompanyConnection.totalCount":
		if e.complexity.CompanyConnection.TotalCount == nil {
			break
		}

		return e.complexity.CompanyConnection.TotalCount(childComplexity), true

	case "CompanyEdge.cursor":
		if e.complexity.CompanyEdge.Cursor == nil {
			break
		}

		return e.complexity.CompanyEdge.Cursor(childComplexity), true

	case "CompanyEdge.node":
		if e.complexity.CompanyEdge.Node == nil {
			break
		}

		return e.complexity.CompanyEdge.Node(childComplexity), true

	case "CompanyViewerPermission.canCreate":
		if e.complexity.CompanyViewerPermission.CanCreate == nil {
			break
		}

		return e.complexity.CompanyViewerPermission.CanCreate(childComplexity), true

	case "CompanyViewerPermission.canDelete":
		if e.complexity.CompanyViewerPermission.CanDelete == nil {
			break
		}

		return e.complexity.CompanyViewerPermission.CanDelete(childComplexity), true

	case "CompanyViewerPermission.canUpdate":
		if e.complexity.CompanyViewerPermission.CanUpdate == nil {
			break
		}

		return e.complexity.CompanyViewerPermission.CanUpdate(childComplexity), true

	case "CreateCompanyPayload.clientMutationId":
		if e.complexity.CreateCompanyPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.CreateCompanyPayload.ClientMutationID(childComplexity), true

	case "CreateCompanyPayload.company":
		if e.complexity.CreateCompanyPayload.Company == nil {
			break
		}

		return e.complexity.CreateCompanyPayload.Company(childComplexity), true

	case "CreateTaskPayload.clientMutationId":
		if e.complexity.CreateTaskPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.CreateTaskPayload.ClientMutationID(childComplexity), true

	case "CreateTaskPayload.task":
		if e.complexity.CreateTaskPayload.Task == nil {
			break
		}

		return e.complexity.CreateTaskPayload.Task(childComplexity), true

	case "CreateUserPayload.clientMutationId":
		if e.complexity.CreateUserPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.CreateUserPayload.ClientMutationID(childComplexity), true

	case "CreateUserPayload.user":
		if e.complexity.CreateUserPayload.User == nil {
			break
		}

		return e.complexity.CreateUserPayload.User(childComplexity), true

	case "DeleteCompanyPayload.clientMutationId":
		if e.complexity.DeleteCompanyPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.DeleteCompanyPayload.ClientMutationID(childComplexity), true

	case "DeleteCompanyPayload.company":
		if e.complexity.DeleteCompanyPayload.Company == nil {
			break
		}

		return e.complexity.DeleteCompanyPayload.Company(childComplexity), true

	case "DeleteTaskPayload.clientMutationId":
		if e.complexity.DeleteTaskPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.DeleteTaskPayload.ClientMutationID(childComplexity), true

	case "DeleteTaskPayload.task":
		if e.complexity.DeleteTaskPayload.Task == nil {
			break
		}

		return e.complexity.DeleteTaskPayload.Task(childComplexity), true

	case "DeleteUserPayload.clientMutationId":
		if e.complexity.DeleteUserPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.DeleteUserPayload.ClientMutationID(childComplexity), true

	case "DeleteUserPayload.user":
		if e.complexity.DeleteUserPayload.User == nil {
			break
		}

		return e.complexity.DeleteUserPayload.User(childComplexity), true

	case "Mutation.createCompany":
		if e.complexity.Mutation.CreateCompany == nil {
			break
		}

		args, err := ec.field_Mutation_createCompany_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCompany(childComplexity, args["input"].(model.CreateCompanyInput)), true

	case "Mutation.createTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_createTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["input"].(model.CreateTaskInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.CreateUserInput)), true

	case "Mutation.deleteCompany":
		if e.complexity.Mutation.DeleteCompany == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCompany_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCompany(childComplexity, args["input"].(model.DeleteCompanyInput)), true

	case "Mutation.deleteTask":
		if e.complexity.Mutation.DeleteTask == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTask(childComplexity, args["input"].(model.DeleteTaskInput)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["input"].(model.DeleteUserInput)), true

	case "Mutation.updateCompany":
		if e.complexity.Mutation.UpdateCompany == nil {
			break
		}

		args, err := ec.field_Mutation_updateCompany_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCompany(childComplexity, args["input"].(model.UpdateCompanyInput)), true

	case "Mutation.updateTask":
		if e.complexity.Mutation.UpdateTask == nil {
			break
		}

		args, err := ec.field_Mutation_updateTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTask(childComplexity, args["input"].(model.UpdateTaskInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(model.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.companies":
		if e.complexity.Query.Companies == nil {
			break
		}

		args, err := ec.field_Query_companies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Companies(childComplexity, args["after"].(*string), args["first"].(*int), args["before"].(*string), args["last"].(*int), args["filterBy"].(*model.CompanyFilter), args["orderBy"].([]*model.CompanyOrder)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["after"].(*string), args["first"].(*int), args["before"].(*string), args["last"].(*int), args["filterBy"].(*model.TaskFilter), args["orderBy"].([]*model.TaskOrder)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*string), args["first"].(*int), args["before"].(*string), args["last"].(*int), args["filterBy"].(*model.UserFilter), args["orderBy"].([]*model.UserOrder)), true

	case "Task.assignee":
		if e.complexity.Task.Assignee == nil {
			break
		}

		return e.complexity.Task.Assignee(childComplexity), true

	case "Task.createdAt":
		if e.complexity.Task.CreatedAt == nil {
			break
		}

		return e.complexity.Task.CreatedAt(childComplexity), true

	case "Task.description":
		if e.complexity.Task.Description == nil {
			break
		}

		return e.complexity.Task.Description(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.title":
		if e.complexity.Task.Title == nil {
			break
		}

		return e.complexity.Task.Title(childComplexity), true

	case "Task.updatedAt":
		if e.complexity.Task.UpdatedAt == nil {
			break
		}

		return e.complexity.Task.UpdatedAt(childComplexity), true

	case "Task.viewerPermission":
		if e.complexity.Task.ViewerPermission == nil {
			break
		}

		return e.complexity.Task.ViewerPermission(childComplexity), true

	case "TaskConnection.edges":
		if e.complexity.TaskConnection.Edges == nil {
			break
		}

		return e.complexity.TaskConnection.Edges(childComplexity), true

	case "TaskConnection.nodes":
		if e.complexity.TaskConnection.Nodes == nil {
			break
		}

		return e.complexity.TaskConnection.Nodes(childComplexity), true

	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true

	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskEdge.cursor":
		if e.complexity.TaskEdge.Cursor == nil {
			break
		}

		return e.complexity.TaskEdge.Cursor(childComplexity), true

	case "TaskEdge.node":
		if e.complexity.TaskEdge.Node == nil {
			break
		}

		return e.complexity.TaskEdge.Node(childComplexity), true

	case "TaskViewerPermission.canCreate":
		if e.complexity.TaskViewerPermission.CanCreate == nil {
			break
		}

		return e.complexity.TaskViewerPermission.CanCreate(childComplexity), true

	case "TaskViewerPermission.canDelete":
		if e.complexity.TaskViewerPermission.CanDelete == nil {
			break
		}

		return e.complexity.TaskViewerPermission.CanDelete(childComplexity), true

	case "TaskViewerPermission.canUpdate":
		if e.complexity.TaskViewerPermission.CanUpdate == nil {
			break
		}

		return e.complexity.TaskViewerPermission.CanUpdate(childComplexity), true

	case "UpdateCompanyPayload.clientMutationId":
		if e.complexity.UpdateCompanyPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.UpdateCompanyPayload.ClientMutationID(childComplexity), true

	case "UpdateCompanyPayload.company":
		if e.complexity.UpdateCompanyPayload.Company == nil {
			break
		}

		return e.complexity.UpdateCompanyPayload.Company(childComplexity), true

	case "UpdateTaskPayload.clientMutationId":
		if e.complexity.UpdateTaskPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.UpdateTaskPayload.ClientMutationID(childComplexity), true

	case "UpdateTaskPayload.task":
		if e.complexity.UpdateTaskPayload.Task == nil {
			break
		}

		return e.complexity.UpdateTaskPayload.Task(childComplexity), true

	case "UpdateUserPayload.clientMutationId":
		if e.complexity.UpdateUserPayload.ClientMutationID == nil {
			break
		}

		return e.complexity.UpdateUserPayload.ClientMutationID(childComplexity), true

	case "UpdateUserPayload.user":
		if e.complexity.UpdateUserPayload.User == nil {
			break
		}

		return e.complexity.UpdateUserPayload.User(childComplexity), true

	case "User.age":
		if e.complexity.User.Age == nil {
			break
		}

		return e.complexity.User.Age(childComplexity), true

	case "User.company":
		if e.complexity.User.Company == nil {
			break
		}

		return e.complexity.User.Company(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.description":
		if e.complexity.User.Description == nil {
			break
		}

		return e.complexity.User.Description(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.tasks":
		if e.complexity.User.Tasks == nil {
			break
		}

		args, err := ec.field_User_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Tasks(childComplexity, args["after"].(*string), args["first"].(*int), args["before"].(*string), args["last"].(*int), args["filterBy"].(*model.TaskFilter), args["orderBy"].([]*model.TaskOrder)), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.viewerPermission":
		if e.complexity.User.ViewerPermission == nil {
			break
		}

		return e.complexity.User.ViewerPermission(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.nodes":
		if e.complexity.UserConnection.Nodes == nil {
			break
		}

		return e.complexity.UserConnection.Nodes(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	case "UserViewerPermission.canCreate":
		if e.complexity.UserViewerPermission.CanCreate == nil {
			break
		}

		return e.complexity.UserViewerPermission.CanCreate(childComplexity), true

	case "UserViewerPermission.canDelete":
		if e.complexity.UserViewerPermission.CanDelete == nil {
			break
		}

		return e.complexity.UserViewerPermission.CanDelete(childComplexity), true

	case "UserViewerPermission.canUpdate":
		if e.complexity.UserViewerPermission.CanUpdate == nil {
			break
		}

		return e.complexity.UserViewerPermission.CanUpdate(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBooleanFilter,
		ec.unmarshalInputCompanyFilter,
		ec.unmarshalInputCompanyOrder,
		ec.unmarshalInputCreateCompanyInput,
		ec.unmarshalInputCreateTaskInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputDeleteCompanyInput,
		ec.unmarshalInputDeleteTaskInput,
		ec.unmarshalInputDeleteUserInput,
		ec.unmarshalInputEnumFilter,
		ec.unmarshalInputFloatFilter,
		ec.unmarshalInputIDFilter,
		ec.unmarshalInputIntFilter,
		ec.unmarshalInputStringFilter,
		ec.unmarshalInputTaskFilter,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTimeFilter,
		ec.unmarshalInputUpdateCompanyInput,
		ec.unmarshalInputUpdateTaskInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserFilter,
		ec.unmarshalInputUserOrder,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/schema.genx.graphql", Input: `#

scalar Time
#

scalar Cursor
#

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}
#

enum OrderDirection {
  ASC
  DESC
}
#

input StringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  isNull: Boolean
  fold: Boolean
}
#

input IntFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  isNull: Boolean
}
#

input FloatFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  isNull: Boolean
}
#

input BooleanFilter {
  equals: String
  not: String
  isNull: Boolean
}
#

input TimeFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  isNull: Boolean
}
#

input IDFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  isNull: Boolean
  fold: Boolean
}
#

input EnumFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  isNull: Boolean
}
#

type Company {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  description: String
  employees(after: Cursor, first: Int, before: Cursor, last: Int, filterBy: UserFilter, orderBy: [UserOrder!]): UserConnection!
  viewerPermission: CompanyViewerPermission!
}
#

type CompanyConnection {
  nodes: [Company!]!
  edges: [CompanyEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}
#

type CompanyEdge {
  node: Company!
  cursor: Cursor!
}
#

input CompanyFilter {
  not: CompanyFilter
  and: [CompanyFilter!]
  or: [CompanyFilter!]
  id: IDFilter
  createdAt: TimeFilter
  updatedAt: TimeFilter
  name: StringFilter
  description: StringFilter
}
#

input CompanyOrder {
  field: CompanyOrderField!
  direction: OrderDirection!
}
#

enum CompanyOrderField {
  ID
  CREATED_AT
  UPDATED_AT
  NAME
  DESCRIPTION
}
#

input CreateCompanyInput {
  clientMutationId: String
  name: String!
  description: String
}
#

type CreateCompanyPayload {
  clientMutationId: String
  company: Company!
}
#

input UpdateCompanyInput {
  clientMutationId: String
  companyId: ID!
  name: String
  description: String
}
#

type UpdateCompanyPayload {
  clientMutationId: String
  company: Company!
}
#

input DeleteCompanyInput {
  clientMutationId: String
  companyId: ID!
}
#

type DeleteCompanyPayload {
  clientMutationId: String
  company: Company!
}
#

type CompanyViewerPermission {
  canCreate: Boolean!
  canUpdate: Boolean!
  canDelete: Boolean!
}
#

type User {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  description: String
  age: Int!
  company: Company!
  tasks(after: Cursor, first: Int, before: Cursor, last: Int, filterBy: TaskFilter, orderBy: [TaskOrder!]): TaskConnection!
  viewerPermission: UserViewerPermission!
}
#

type UserConnection {
  nodes: [User!]!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}
#

type UserEdge {
  node: User!
  cursor: Cursor!
}
#

input UserFilter {
  not: UserFilter
  and: [UserFilter!]
  or: [UserFilter!]
  id: IDFilter
  createdAt: TimeFilter
  updatedAt: TimeFilter
  name: StringFilter
  description: StringFilter
  age: IntFilter
  company: CompanyFilter
}
#

input UserOrder {
  field: UserOrderField!
  direction: OrderDirection!
}
#

enum UserOrderField {
  ID
  CREATED_AT
  UPDATED_AT
  NAME
  DESCRIPTION
  AGE
}
#

input CreateUserInput {
  clientMutationId: String
  name: String!
  description: String
  age: Int!
  companyId: ID!
}
#

type CreateUserPayload {
  clientMutationId: String
  user: User!
}
#

input UpdateUserInput {
  clientMutationId: String
  userId: ID!
  name: String
  description: String
  age: Int
  companyId: ID
}
#

type UpdateUserPayload {
  clientMutationId: String
  user: User!
}
#

input DeleteUserInput {
  clientMutationId: String
  userId: ID!
}
#

type DeleteUserPayload {
  clientMutationId: String
  user: User!
}
#

type UserViewerPermission {
  canCreate: Boolean!
  canUpdate: Boolean!
  canDelete: Boolean!
}
#

enum TaskStatus {
  OPEN
  IN_PROGRESS
  DONE
}
#

type Task {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  title: String!
  description: String
  status: TaskStatus!
  assignee: User
  viewerPermission: TaskViewerPermission!
}
#

type TaskConnection {
  nodes: [Task!]!
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}
#

type TaskEdge {
  node: Task!
  cursor: Cursor!
}
#

input TaskFilter {
  not: TaskFilter
  and: [TaskFilter!]
  or: [TaskFilter!]
  id: IDFilter
  createdAt: TimeFilter
  updatedAt: TimeFilter
  title: StringFilter
  description: StringFilter
  status: EnumFilter
  assignee: UserFilter
}
#

input TaskOrder {
  field: TaskOrderField!
  direction: OrderDirection!
}
#

enum TaskOrderField {
  ID
  CREATED_AT
  UPDATED_AT
  TITLE
  DESCRIPTION
  STATUS
}
#

input CreateTaskInput {
  clientMutationId: String
  title: String!
  description: String
  status: TaskStatus!
  assigneeId: ID
}
#

type CreateTaskPayload {
  clientMutationId: String
  task: Task!
}
#

input UpdateTaskInput {
  clientMutationId: String
  taskId: ID!
  title: String
  description: String
  status: TaskStatus
  assigneeId: ID
}
#

type UpdateTaskPayload {
  clientMutationId: String
  task: Task!
}
#

input DeleteTaskInput {
  clientMutationId: String
  taskId: ID!
}
#

type DeleteTaskPayload {
  clientMutationId: String
  task: Task!
}
#

type TaskViewerPermission {
  canCreate: Boolean!
  canUpdate: Boolean!
  canDelete: Boolean!
}
#

extend type Query {
  companies(after: Cursor, first: Int, before: Cursor, last: Int, filterBy: CompanyFilter, orderBy: [CompanyOrder!]): CompanyConnection!
}
#

extend type Mutation {
  createCompany(input: CreateCompanyInput!): CreateCompanyPayload!
  updateCompany(input: UpdateCompanyInput!): UpdateCompanyPayload!
  deleteCompany(input: DeleteCompanyInput!): DeleteCompanyPayload!
}
#

extend type Query {
  users(after: Cursor, first: Int, before: Cursor, last: Int, filterBy: UserFilter, orderBy: [UserOrder!]): UserConnection!
}
#

extend type Mutation {
  createUser(input: CreateUserInput!): CreateUserPayload!
  updateUser(input: UpdateUserInput!): UpdateUserPayload!
  deleteUser(input: DeleteUserInput!): DeleteUserPayload!
}
#

extend type Query {
  tasks(after: Cursor, first: Int, before: Cursor, last: Int, filterBy: TaskFilter, orderBy: [TaskOrder!]): TaskConnection!
}
#

extend type Mutation {
  createTask(input: CreateTaskInput!): CreateTaskPayload!
  updateTask(input: UpdateTaskInput!): UpdateTaskPayload!
  deleteTask(input: DeleteTaskInput!): DeleteTaskPayload!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
